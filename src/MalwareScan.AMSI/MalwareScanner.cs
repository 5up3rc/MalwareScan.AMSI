namespace MalwareScan.AMSI
{
    using System;
    using System.IO;

    /// <summary>
    /// Provides a wrapper for the AMSI interface on Windows 10+ and Windows Server 2016+
    /// <exception cref="AMSIException">May throw an AMSIException if any call to the AMSI interface fails unexpectedly.</exception>
    /// </summary>
    public class MalwareScanner : IDisposable
    {
         // TODO: Detect if virus scanner is actually present!
        // TODO: Detect if API is present

        // This currently calls AmsiInitalise once for the whole class and then
        // opens a session for each call to the scanning service.
        // Need to do some performance testing to see if there is a benefit to sharing a session,
        // Maybe by passing in an array of streams or something?
        private readonly string appName = "MalwareScanner.AMSI";

        private readonly Lazy<IntPtr> amsiContextLazy;

        public MalwareScanner() : this(String.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="MalwareScanner"/> class. 
        /// The instance will keep a reference to the OS malware scanning service, i.e.
        /// AmsiInitialize (https://msdn.microsoft.com/en-us/library/windows/desktop/dn889862(v=vs.85).aspx),
        /// which will be release on dispose or destruction.
        /// </summary>
        /// <param name="applicationName">
        /// If specified, this application name is passed to Windows when scanning. Defaults to 'MalwareScanner.AMSI'
        /// </param>
        public MalwareScanner(string applicationName)
        {
            if (!String.IsNullOrWhiteSpace(applicationName))
            {
                this.appName = applicationName;
            }

            this.amsiContextLazy = new Lazy<IntPtr>(
                () =>
                    {
                        IntPtr ctx;
                        int result;
                        try
                        {
                            result = AmsiWrapper.AmsiInitialize(this.appName, out ctx);
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine(e);
                            throw new AMSIException($"Failed to initialise AMSI (the first thing we do): {e.Message}. See the inner exception for more details.", e);
                        }

                        if (result != 0)
                        {
                            throw new AMSIException($"Failed to open an AMSI Session - the Initialise call returned {result}");
                        }

                        return ctx;
                    });
        }

        /// <summary>
        /// Scans a stream for virus
        /// </summary>
        /// <param name="stream">
        /// If the stream supports seeking, such as, say, a MemoryStream or FileStream then this will work fine.
        /// The scanner will go back to the start and read to the end and reset the position back to wherever you had it.
        /// However, if you want to scan, say, the input stream in a web app then it may not be possible to rewind the stream,
        /// meaning you can't then access the stream content yourself after the scanner has read it.
        /// Similarly, the scanner can only read the stream from the point where it is when when you pass it in. 
        /// There are scenarios where that is fine, but usually you'd want to first copy the forward-only stream to a memory stream, 
        /// and then scan the memory stream. Don't forget to set the position to 0 before you start reading it yourself as the stream copy
        /// will leave it at the end of the stream.
        /// </param>
        /// <param name="filename">The name of the file. It is passed on to the virus scanner and *may* be used in determining scanning algorithms or it may be ignored - the AMSI documentation is not extensive.</param>
        /// <returns>true if the scanned content contains malware and should be blocked. Otherwise, false</returns>
        public bool HasVirus(Stream stream, string filename)
        {
            return this.HasVirus(CopyToByteArray(stream), filename);
        }

        /// <summary>
        /// Will scann the byte array for a virus.
        /// </summary>
        /// <param name="bytearray">A byte array with content you want scanned, usually the contents of a file.</param>
        /// <param name="filename">The name of the file. It is passed on to the virus scanner and *may* be used in determining scanning algorithms or it may be ignored - the AMSI documentation is not extensive.</param>
        /// <returns>True if a virus was detected, false in all other cases.</returns>
        public bool HasVirus(byte[] bytearray, string filename)
        {
            // TODO: Parameter validation
            IntPtr session = IntPtr.Zero;
            
            try
            {
                session = this.OpenSession();
                var scanResult = this.Scan(bytearray, filename, session);

                return HasMalware(scanResult);
            }
            finally
            {
                if (session != IntPtr.Zero)
                {
                    AmsiWrapper.AmsiCloseSession(this.amsiContextLazy.Value, session);
                }
            }
        }

        public void Dispose()
        {
            this.ReleaseUnmanagedResources();
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Courtesy of https://stackoverflow.com/questions/1080442/how-to-convert-an-stream-into-a-byte-in-c
        /// </summary>
        /// <param name="stream">An input stream</param>
        /// <returns>A byte array</returns>
        private static byte[] CopyToByteArray(Stream stream)
        {
            long originalPosition = 0;

            if (stream.CanSeek)
            {
                originalPosition = stream.Position;
                stream.Position = 0;
            }

            try
            {
                byte[] readBuffer = new byte[4096];

                int totalBytesRead = 0;
                int bytesRead;

                while ((bytesRead = stream.Read(readBuffer, totalBytesRead, readBuffer.Length - totalBytesRead)) > 0)
                {
                    totalBytesRead += bytesRead;

                    if (totalBytesRead == readBuffer.Length)
                    {
                        int nextByte = stream.ReadByte();
                        if (nextByte != -1)
                        {
                            byte[] temp = new byte[readBuffer.Length * 2];
                            Buffer.BlockCopy(readBuffer, 0, temp, 0, readBuffer.Length);
                            Buffer.SetByte(temp, totalBytesRead, (byte)nextByte);
                            readBuffer = temp;
                            totalBytesRead++;
                        }
                    }
                }

                byte[] buffer = readBuffer;
                if (readBuffer.Length != totalBytesRead)
                {
                    buffer = new byte[totalBytesRead];
                    Buffer.BlockCopy(readBuffer, 0, buffer, 0, totalBytesRead);
                }

                return buffer;
            }
            finally
            {
                if (stream.CanSeek)
                {
                    stream.Position = originalPosition;
                }
            }
        }

        private static bool HasMalware(AMSI_RESULT scanResult)
        {
            try
            {
                var isSafe = scanResult == AMSI_RESULT.AMSI_RESULT_CLEAN 
                             || scanResult == AMSI_RESULT.AMSI_RESULT_NOT_DETECTED;
                return !isSafe;
            }
            catch (Exception e)
            {
                throw new AMSIException($"Failed to interpret result. When 'AMSIResultIsMalware' was called with {scanResult} it threw {e.Message}. See the inner exception for details.", e);
            }
        }

        private AMSI_RESULT Scan(byte[] bytearray, string filename, IntPtr session)
        {
            int result;
            var length = Convert.ToUInt32(bytearray.Length);
            AMSI_RESULT scanResult;
            try
            {
                result = AmsiWrapper.AmsiScanBuffer(this.amsiContextLazy.Value, bytearray, length, filename, session, out scanResult);
            }
            catch (Exception e)
            {
                throw new AMSIException(
                    $"An unexpected error occured calling AmsiScanBuffer: {e.Message}. See the inner exception for more details.",
                    e);
            }

            if (result != 0)
            {
                throw new AMSIException($"Failed to scan {filename}. The call to AmsiScanBuffer returned {result}.");
            }

            return scanResult;
        }

        private IntPtr OpenSession()
        {
            IntPtr session;
            int result;
            try
            {
                result = AmsiWrapper.AmsiOpenSession(this.amsiContextLazy.Value, out session);
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
                throw new AMSIException($"Failed to open an AMSI Session: {e.Message}. See the inner exception for details.", e);
            }

            if (result != 0)
            {
                throw new AMSIException($"Failed to open an AMSI Session - the OpenSession call returned {result}");
            }

            return session;
        }

        private void ReleaseUnmanagedResources()
        {
            try
            {
                if (this.amsiContextLazy.IsValueCreated)
                {
                    AmsiWrapper.AmsiUninitialize(this.amsiContextLazy.Value);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        ~MalwareScanner()
        {
            this.ReleaseUnmanagedResources();
        }
    }
}
